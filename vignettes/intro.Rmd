---
title: "Introduction to faux"
author: "Lisa DeBruine"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to faux}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  fig.width = 8,
  fig.height = 5,
  collapse = TRUE,
  comment = "#>"
)

library(ggplot2)
library(dplyr)
library(tidyr)
library(faux)
theme_set(theme_bw())
set.seed(200)
```


It is useful to be able to simulate data with a specified structure. The `faux` package provides some functions to make this process easier.

## sim_design

This function creates a dataset with a specific between- and within-subjects design. [see vignette](sim_design.html)

For example, the following creates a 2w*2b design with 100 observations in each cell. The between-subject factor is `pet` with twolevels of `cat` and `dog`. The within-subject factor is `time` with two levels of `day` and `night`. The mean for the `cat_day` cell is 10, the mean for the `cat_night` cell is 20, the mean for the `dog_day` cell is 15, and the mean for the `dog_night` cell is 25. All cells have a SD of 5 and all within-subject cells are correlated <code>r = 0.5</code>. The resulting data has exactly these values (set `empirical = FALSE` to sample from a population with these values).


```{r}
between <- list("pet" = c("cat", "dog"))
within <- list("time" = c("day", "night"))
mu <- data.frame(
  cat = c(10, 20),
  dog = c(15, 25),
  row.names = within$time
)
df <- sim_design(within, between, 
                 n = 100, cors = 0.5, mu = mu, sd = 5,
                 empirical = TRUE)
```

`r check_sim_stats(df, grp_by = "pet", usekable = TRUE)`
Table: Sample `sim_design()` stats

## rnorm_multi

This function makes multiple normally distributed vectors with specified parameters and relationships.[see vignette](rnorm_multi.html)

For example, the following creates a sample that has 100 observations of 3 variables, drawn from a population where where A correlates with B and C with r = 0.5, and B and C correlate with r = 0.25. A has a mean of 0 and SD of 1, while B and C have means of 20 and SDs of 5.

```{r multirnorm-example}

dat <- rnorm_multi(
  n = 100, 
  cors = c(0.5, 0.5, 0.25), 
  mu = c(0, 20, 20),
  sd = c(1, 5, 5),
  varnames = c("A", "B", "C"),
  empirical = FALSE
)

```


`r check_sim_stats(dat, usekable = T)`
Table: Sample `rnorm_multi()` stats


## simdf

This function produces a dataframe with the same distributions and correlations as an existing dataframe. It only returns numeric columns and simulates all numeric variables from a continuous normal distribution (for now). [see vignette](simdf.html)

For example, the following code creates a new sample from the built-in dataset `iris` with 50 observations of each species.

```{r}
new_iris <- simdf(iris, 50, "Species") 
```

```{r plot-iris-sim, echo = FALSE, fig.cap="Simulated iris dataset"}
new_iris %>%
  ggplot(aes(Sepal.Width, Sepal.Length, color = Species)) +
  geom_point() +
  geom_smooth(method = "lm")
```

## Additional functions

### check_sim_stats

If you want to check your simulated stats or just describe an existing dataset, use `check_sim_stats()`.

```{r}
check_sim_stats(iris)
```

You can also group your data and change the digits to round. Display the table using `knitr::kable()` by setting `usekable` to `TRUE` (remember to set `results='asis'` in the chunk header.

```{r, results='asis'}
check_sim_stats(iris, 
                grp_by = "Species", 
                digits = 3, 
                usekable = TRUE)
```


### pos_def_limits

Not all correlation matrices are possible. For example, if variables A and B are correlated with r = 1.0, then the correlation between A and C can only be exactly equal to the correlation between B and C.

The function `pos_def_limits()` lets you know what the possible range of values is for the missing value in a correlation matrix with one missing value. The correlation values are entered just from the top right triangle of the matrix, with a single `NA` for the missing value.

```{r pos_def_limits1}
lims <- pos_def_limits(.8, .2, NA)
```

`r knitr::kable(lims)`

For example, if r~AB~ = 0.8 and r~AC~ = 0.2, then `r lims$min` <= r~BC~ <= `r lims$max`.

If you enter a correlation matrix that contains impossible combinations, your limits will be `NA`.

```{r pos_def_limits-na}
lims <- pos_def_limits(.8, .2,  0,
                          -.5, NA,
                               .2)
```

`r knitr::kable(lims)`

If you have a full matrix and want to know if it is positive definite, you can use the following code:

```{r is_pos_def}
c(.2, .3, .4, .2,
      .3, -.1, .2,
           .4, .5,
               .3) %>%
  cormat_from_triangle() %>%
  is_pos_def()
```

```{r not_pos_def}
matrix(c(1, .3, -.9, .2,
        .3,  1,  .4, .5,
       -.9, .4,   1, .3,
        .2, .5,  .3,  1), 4) %>%
  is_pos_def()
```





