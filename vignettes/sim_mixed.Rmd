---
title: "sim_mixed"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sim_mixed}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, warning=FALSE, message=FALSE}
library(faux)
library(tidyverse)
```

The function `sim_mixed_cc()` produces a data table for a basic cross-classified design with random intercepts for subjects and items. 

For example, the following code produces the data for 100 subjects responding to 50 items where the response has an overall mean (`grand_i`) of 10. Subjects vary in their average response with an SD of 1, items vary in their average response with an SD of 2, and the residual error term has an SD of 3.

```{r}
dat_cc <- sim_mixed_cc(
  sub_n = 100,   # subject sample size
  item_n = 50,  # item sample size
  grand_i = 10,  # overall mean of the score
  sub_sd = 1,   # SD of subject random intercepts
  item_sd = 2,  # SD of item random intercepts
  error_sd = 3  # SD of residual error
)
```

You can then see how changing these numbers affects the random effects in an intercept-only mixed effects model.

```{r, results='asis'}
lme4::lmer(val ~ 1 + (1 | sub_id) + (1 | item_id), data = dat_cc) %>%
  broom.mixed::tidy() %>%
  knitr::kable(digits = 3)
```

You can also add effects to this intercept model. For example, you can add a between-subjects factor of condition (A or B) that has an efect size of 0.5 and a within-item factor of time (pre or post) that has an effect size of 0.25.

```{r}

# set up between-subject factor
sub <- data.frame(
  sub_id = unique(dat_cc$sub_id)
) %>%
  mutate(condition = rep(c("A", "B"), length.out = nrow(.)))

# set up within- factors
trials <- expand.grid(
  sub_id = sub$sub_id,
  item_id = unique(dat_cc$item_id),
  time = c("pre", "post")
)

condition_effect <- 0.5
time_effect <- 0.25

# add subject and cc data to trials
sim_dat <- trials %>%
  left_join(sub, by = "sub_id") %>%
  left_join(dat_cc, by = c("sub_id", "item_id")) %>%
  mutate(
    condition.e = recode(condition, "A" = -0.5, "B" = 0.5),
    time.e = recode(time, "pre" = -0.5, "post" = 0.5),
    err = rnorm(nrow(.), 0, sd(dat_cc$err)), # redo the error term
    dv = grand_i + sub_i + item_i + err + 
      (condition.e * condition_effect) + 
      (time.e * time_effect)
  )

```
Add time and condition to your model. Try changing the effect sizes and see how the estimate changes.

```{r, results='asis'}
lme4::lmer(dv ~ 1 + time.e + condition.e + 
             (1 | sub_id) + 
             (1 | item_id), 
           data = sim_dat) %>%
  broom.mixed::tidy() %>%
  knitr::kable(digits = 3)
```

